# -*- coding: utf-8 -*-
"""python_ex03_oop.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h7k2N69aauGEYZI9AOkA7XMlEcF9SIfA

**Ex 1. Budowa klasy**
"""

class Point:
  def __init__(self,x_val,y_val):
    self.x = x_val
    self.y = y_val

  def distance(self, other):
    diff_x = (self.x - other.x) ** 2
    diff_y = (self.y - other.y) ** 2
    return (diff_x + diff_y) ** 0.5

p_1 = Point(3,4)
p_2 = Point(1,2)
print(p_1.distance(p_2))
print(Point.distance(p_1,p_2))

class Point:
  def __init__(self,x_val,y_val):
    self.x = x_val
    self.y = y_val

  def distance(self, other):
    diff_x = (self.x - other.x) ** 2
    diff_y = (self.y - other.y) ** 2
    return (diff_x + diff_y) ** 0.5

class Circle:
  def __init__(self,radius,center):
    if type(center) != Point:
      raise ValueError()
    if type(radius) != int:
      raise ValueError()
    self.radius = radius
    self.center = center

  def is_inside(self, other_p):
    return other_p.distance(self.center) < self.radius

  def is_inside_2(self, other_p):
    return self.center.distance(other_p) < self.radius

center = Point(1,1)
c = Circle(5,center)
p = Point(3,4)
print(c.is_inside(p))
print(c.is_inside_2(p))

c = Circle(5,(0,0))

class Car:
    def __init__(self, make="VW"):
        self.make = make
        self.gear = 0

    def gear_change_up(self):
        if self.gear <= 7:
            self.gear+=1
        print(self.gear)

    def gear_change_down(self):
        if self.gear >= 0:
            self.gear-=1
        print(self.gear)

my_car = Car()
print(my_car.make)
print(my_car.gear)
my_car.gear_change_up()

"""**Ex 2. Dunder methods**
https://docs.python.org/3/reference/datamodel.html
"""

class Fraction():
  def __init__(self,n,d):
    self.num = n
    self.den = d

  def __mul__(self, other):
    m_num = self.num * other.num
    m_den = self.den * other.den
    return Fraction(m_num,m_den)

a = Fraction(1,2)
b = Fraction(5,7)
print(a * b)

class Fraction():
  def __init__(self,n,d):
    self.num = n
    self.den = d

  def __mul__(self, other):
    m_num = self.num * other.num
    m_den = self.den * other.den
    return Fraction(m_num,m_den)

  def __str__(self):
    return "<" + str(self.num) + "/" + str(self.den) + ">"

a = Fraction(1,2)
b = Fraction(5,7)
print(a * b)
print(a.__mul__(b))
print(Fraction.__mul__(a,b))

class Fraction():
  def __init__(self,n,d):
    self.num = n
    self.den = d

  def __mul__(self, other):
    m_num = self.num * other.num
    m_den = self.den * other.den
    return Fraction(m_num,m_den)

  def __str__(self):
    return "<" + str(self.num) + "/" + str(self.den) + ">"

  def __float__(self):
    return self.num/self.den

a = Fraction(1,2)
b = Fraction(5,7)
c = a * b
print(c)
print(type(c))
print(float(c))

class Text:
  def __init__(self, text: str) -> None:
    self.text = text

  def __format__(self, format_spec: str) -> str:
    match format_spec:
      case 'upper':
        return self.text.upper()

      case 'lower':
        return self.text.lower()

      case 'count':
        return str(len(self.text))

      case _:
        raise ValueError(f'Format specifier "{format_spec}" does not exist')

txt: Text = Text('Python')
print(f'{txt:upper}')
print(f'{txt:lower}')
print(f'{txt:count}')
print(f'{txt:undescore}')

"""**Ex 3. Hermetyzacja**"""

class Encapsulation:
    def __init__(self):
        self.public, self._protected, self.__private = 1, 2, 3

def main():
    encapsulation = Encapsulation()
    print(encapsulation.public)
    print(encapsulation._protected)
    print(encapsulation._Encapsulation__private)
# a teraz będzie błąd
    print(encapsulation.__private)

main()

class Encapsulation:
  def __init__(self):
      self.public, self._protected, self.__private = 1, 2, 3

  def get_private(self):
    return self.__private

  def set_private(self,prv):
    self.__private = prv

  def __str__(self):
    return f'{self.__private}'

e = Encapsulation()
print(e)
e.set_private(10)
print(e)

"""**Ex 4. Pola statyczne. Metody statyczne.**"""

class Car:
    how_many = 0

    def __init__(self):
        Car.how_many += 1
        self.car_number = Car.how_many
        print(f"Number of car is equal to {self.car_number}")

    def __del__(self):
        Car.how_many -= 1

    @staticmethod
    def count_cars():
        return Car.how_many

car_1 = Car()
car_2 = Car()
car_3 = Car()
print(f"Total number of cars {Car.count_cars()}")
car_2 = None
print(f"Total number of cars {Car.count_cars()}")

"""**Zad 5. Dziedziczenie**"""

class Person:
    def __init__(self,name,surname,age):
        self.name = name
        self.surname = surname
        self.age = age

    def hasName(self):
        print("Has name")

class Student(Person):
    def __init__(self,name,surname,age,field_of_study):
        super().__init__(name,surname,age)
        self.field_of_study = field_of_study

    def isStudent(self):
        print("Is student")

person_1 = Person("Tom","Nowak",25)
student_1 = Student("Tom","Nowak",25,"Informatics")

student_1.hasName()